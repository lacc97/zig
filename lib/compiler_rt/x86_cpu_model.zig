//! Thus file implements x86/x86_64 CPU detection compatible with LLVM/Clang
//! (i.e. multiversioned functions with attribute `target` or `target_clones`) which
//! itself is compatible with libgcc multiversioning.
//!
//! The following function implementations should be reviewed after any update to
//! the autogenerated file lib/compiler_rt/cpu_model/x86.zig in case there's new CPU
//! type/subtype definitions from LLVM (specifically in compiler-rt/lib/builtins/cpu_mode/x86.c):
//!     - getAmdTypeAndSubtype()
//!     - getIntelTypeAndSubtype()
//!
//! In upstream LLVM, the directly relevant files for x86 CPU detection are
//!  - llvm/include/llvm/TargetParser/X86TargetParser.def: enum definitions and values
//!  - compiler-rt/lib/builtins/cpu_mode/x86.c: LLVM runtime implementation of x86 cpu detection
//!                                             and symbol definitions
//!
//! Related LLVM files are
//!  - llvm/include/llvm/TargetParse/X86TargetParser.h
//!    llvm/lib/TargetParser/X86TargetParser.cpp: LLVM helpers for x86 cpu detection
//!  - clang/lib/CodeGen/CGBuiltin.cpp: Clang code that emits x86 feture detection code
//!

const builtin = @import("builtin");
const std = @import("std");
const x86 = std.zig.system.x86;

const common = @import("common.zig");

const Target = std.Target;

comptime {
    const linkage: std.builtin.GlobalLinkage = common.linkage;
    const visibility: std.builtin.SymbolVisibility = if (linkage != .internal) .hidden else .default;

    @export(&cpu, .{ .name = "__cpu_model", .linkage = linkage, .visibility = visibility });
    @export(&cpu_extra_features, .{ .name = "__cpu_features2", .linkage = linkage, .visibility = visibility });
    @export(&init, .{ .name = "__cpu_indicator_init", .linkage = linkage, .visibility = visibility });
}

var cpu: Model = .{};
var cpu_extra_features: [feature_set_size - 1]u32 = [_]u32{0} ** (feature_set_size - 1);

// TODO: Do we need constructor attribute? As far as I can tell the generated LLVM detection code explicitly
//       calls __cpu_indicator_init before actually using __cpu_model or __cpu_features2 (happens in
//       clang/lib/CodeGen/CGBuiltin.cpp)
fn init() callconv(.C) c_int {
    if (cpu.vendor != .unknown) return 0;

    const vendor, const family, const model = blk: {
        const v, const fm = x86.detectNativeModel();
        break :blk .{ v, if (fm) |x| x.family else 0, if (fm) |x| x.model else 0 };
    };

    const features = blk: {
        var detected = Target.Cpu.Feature.Set.empty;
        x86.detectNativeFeatures(&detected, builtin.os.tag);

        var features = std.mem.zeroes(FeatureSet);
        inline for (@typeInfo(Target.x86.Feature).@"enum".fields) |f| {
            const index: Target.Cpu.Feature.Set.Index = f.value;
            if (comptime !@hasField(Feature, f.name)) continue;
            if (detected.isEnabled(index)) setFeature(&features, @field(Feature, f.name));
        }

        const isDetected = struct {
            fn isDetected(set: Target.Cpu.Feature.Set, feats: []const Target.x86.Feature) bool {
                for (feats) |f| {
                    if (!set.isEnabled(@intFromEnum(f))) return false;
                }
                return true;
            }
        }.isDetected;

        // Compared to upstream LLVM,
        //  - FEATURE_LM -> @"64bit"
        if (isDetected(detected, &.{ .@"64bit", .sse2 })) {
            setFeature(&features, .x86_64);

            // Compared to upstream LLVM,
            //  - FEATURE_CMPXCHG16B -> cx16
            //  - FEATURE_LAHF_LM -> sahf
            if (isDetected(detected, &.{ .cx16, .popcnt, .sahf, .sse4_2 })) {
                setFeature(&features, .x86_64_v2);

                if (isDetected(detected, &.{ .avx2, .bmi, .bmi2, .f16c, .fma, .lzcnt, .movbe })) {
                    setFeature(&features, .x86_64_v3);

                    if (isDetected(detected, &.{ .avx512bw, .avx512cd, .avx512dq, .avx512vl })) {
                        setFeature(&features, .x86_64_v4);
                    }
                }
            }
        }

        break :blk features;
    };

    cpu.vendor = switch (vendor) {
        .intel => blk: {
            cpu.type, cpu.subtype = getIntelTypeAndSubtype(family, model, features);
            break :blk .intel;
        },
        .amd => blk: {
            cpu.type, cpu.subtype = getAmdTypeAndSubtype(family, model, features);
            break :blk .amd;
        },
        else => .other,
    };
    cpu.features[0] = features[0];
    cpu_extra_features = features[1..].*;

    return 0;
}

const Model = extern struct {
    vendor: Vendor = .unknown,
    type: Type = .unknown,
    subtype: Subtype = .unknown,
    features: [1]u32 = .{0},
};

const FeatureSet = [feature_set_size]u32;
comptime {
    for (@typeInfo(Feature).@"enum".fields) |f| {
        if (f.value >= @bitSizeOf(FeatureSet))
            @compileError(@import("std").fmt.comptimePrint("Feature.{s} ({}) bitindex too large", .{ f.name, f.value }));
    }
}

fn hasFeature(set: FeatureSet, f: Feature) bool {
    const f_value = @intFromEnum(f);
    const bit = set[f_value / 32] & (@as(u32, 1) << @as(u5, @intCast(f_value % 32)));
    return bit != 0;
}
fn setFeature(set: *FeatureSet, f: Feature) void {
    const f_value = @intFromEnum(f);
    set[f_value / 32] |= (@as(u32, 1) << @as(u5, @intCast(f_value % 32)));
}

const Vendor = @import("cpu_model/x86.zig").Vendor;
const Type = @import("cpu_model/x86.zig").Type;
const Subtype = @import("cpu_model/x86.zig").Subtype;
const Feature = @import("cpu_model/x86.zig").Feature;

const feature_set_size = blk: {
    var max_index: comptime_int = 0;
    for (@typeInfo(Feature).@"enum".fields) |f| {
        if (f.value > max_index) max_index = f.value;
    }
    break :blk (max_index + 32) / 32;
};

comptime {
    // Sanity checking that the feature sets in std.Target.x86 and the autogenerated
    // ones in @This().Feature are compatible.

    const ignored = std.StaticStringMap(void).initComptime(.{
        // These are not present in std/target/x86.zig because they are
        // unimplemented in LLVM's llvm/lib/Target/X86/X86.td.
        .{ "avx5124vnniw", {} },
        .{ "avx5124fmaps", {} },

        // These represent aggregate microarchitecture levels and
        // thus do not correspond to individual features in std.Target.x86.Feature.
        .{ "x86_64", {} },
        .{ "x86_64_v2", {} },
        .{ "x86_64_v3", {} },
        .{ "x86_64_v4", {} },
        .{ "apxf", {} },
    });

    var errors: []const u8 = "";

    for (@typeInfo(Feature).@"enum".fields) |field| {
        if (ignored.has(field.name)) {
            if (@hasField(Target.x86.Feature, field.name)) errors = errors ++ std.fmt.comptimePrint(
                "\n  feature `{s}' present in std.Target.x86.Feature but marked for ignore in compiler-rt",
                .{field.name},
            );
            continue;
        } else if (!@hasField(Target.x86.Feature, field.name)) {
            errors = errors ++ std.fmt.comptimePrint(
                "\n  feature `{s}' missing in std.Target.x86.Feature",
                .{field.name},
            );
        }
    }

    if (errors.len > 0) @compileError("mismatch between compiler-rt feature set and std.Target.x86:" ++ errors);
}

fn getAmdTypeAndSubtype(
    family: u32,
    model: u32,
    features: FeatureSet,
) struct { Type, Subtype } {
    _ = features;

    var t: Type = .unknown;
    var s: Subtype = .unknown;

    switch (family) {
        16, 18 => {
            t = .amdfam10h;
            switch (model) {
                2 => s = .amdfam10h_barcelona,
                4 => s = .amdfam10h_shanghai,
                8 => s = .amdfam10h_istanbul,
                else => {},
            }
        },
        20 => t = .amd_btver1,
        21 => {
            t = .amdfam15h;
            switch (model) {
                0x60...0x7f => s = .amdfam15h_bdver4, // 60h-7Fh: Excavator
                0x30...0x3f => s = .amdfam15h_bdver3, // 30h-3Fh: Steamroller
                0x10...0x1f => s = .amdfam15h_bdver2, // 10h-1Fh: Piledriver
                0x00...0x0f => s = if (model == 0x02)
                    .amdfam15h_bdver2 // 02h: Piledriver
                else
                    .amdfam15h_bdver1, // 00h-0Fh: Bulldozer
                else => {},
            }
        },
        22 => t = .amd_btver2,
        23 => {
            t = .amdfam17h;
            switch (model) {
                0x30...0x3f, // Family 17h Models 30h-3Fh (Starship) Zen 2
                0x47, // Family 17h Models 47h (Cardinal) Zen 2
                0x60...0x67, // Family 17h Models 60h-67h (Renoir) Zen 2
                0x68...0x6f, // Family 17h Models 68h-6Fh (Lucienne) Zen 2
                0x70...0x7f, // Family 17h Models 70h-7Fh (Matisse) Zen 2
                0x84...0x87, // Family 17h Models 84h-87h (ProjectX) Zen 2
                0x90...0x97, // Family 17h Models 90h-97h (VanGogh) Zen 2
                0x98...0x9f, // Family 17h Models 98h-9Fh (Mero) Zen 2
                0xa0...0xaf, // Family 17h Models A0h-AFh (Mendocino) Zen 2
                => s = .amdfam17h_znver2,

                0x10...0x1f, // Family 17h Models 10h-1Fh (Raven1) Zen and Family 17h Models 10h-1Fh (Picasso) Zen+
                0x20...0x2f, // Family 17h Models 20h-2Fh (Raven2 x86) Zen
                => s = .amdfam17h_znver1,

                else => {},
            }
        },
        25 => {
            t = .amdfam19h;
            switch (model) {
                0x00...0x0f, // Family 19h Models 00h-0Fh (Genesis, Chagall) Zen 3
                0x20...0x2f, // Family 19h Models 20h-2Fh (Vermeer) Zen 3
                0x30...0x3f, // Family 19h Models 30h-3Fh (Badami) Zen 3
                0x40...0x4f, // Family 19h Models 40h-4Fh (Rembrandt) Zen 3+
                0x50...0x5f, // Family 19h Models 50h-5Fh (Cezanne) Zen 3
                => s = .amdfam19h_znver3,

                0x10...0x1f, // Family 19h Models 10h-1Fh (Stones; Storm Peak) Zen 4
                0x60...0x6f, // Family 19h Models 60h-6Fh (Raphael) Zen 4
                0x70...0x77, // Family 19h Models 70h-77h (Phoenix, Hawkpoint1) Zen 4
                0x78...0x7f, // Family 19h Models 78h-7Fh (Phoenix 2, Hawkpoint2) Zen 4
                0xa0...0xaf, // Family 19h Models A0h-AFh (Stones-Dense) Zen 4
                => s = .amdfam19h_znver4,
                else => {},
            }
        },
        26 => {
            t = .amdfam1ah;
            if (model <= 0x77) { // Models 00h-77h
                s = .amdfam1ah_znver5;
            }
        },
        else => {},
    }

    return .{ t, s };
}

fn getIntelTypeAndSubtype(
    family: u32,
    model: u32,
    features: FeatureSet,
) struct { Type, Subtype } {
    var t: Type = .unknown;
    var s: Subtype = .unknown;

    switch (family) {
        6 => switch (model) {
            0x0f, 0x16, 0x17, 0x1d => t = .intel_core2,
            0x1a, 0x1e, 0x1f, 0x2e => {
                t = .intel_corei7;
                s = .intel_corei7_nehalem;
            },
            0x25, 0x2c, 0x2f => {
                t = .intel_corei7;
                s = .intel_corei7_westmere;
            },
            0x2a, 0x2d => {
                t = .intel_corei7;
                s = .intel_corei7_sandybridge;
            },
            0x3a, 0x3e => {
                t = .intel_corei7;
                s = .intel_corei7_ivybridge;
            },
            0x3c, 0x3f, 0x45, 0x46 => {
                t = .intel_corei7;
                s = .intel_corei7_haswell;
            },
            0x3d, 0x47, 0x4f, 0x56 => {
                t = .intel_corei7;
                s = .intel_corei7_broadwell;
            },
            0x4e, 0x5e, 0x8e, 0x9e, 0xa5, 0xa6 => {
                t = .intel_corei7;
                s = .intel_corei7_skylake;
            },
            0xa7 => {
                t = .intel_corei7;
                s = .intel_corei7_rocketlake;
            },
            0x55 => {
                t = .intel_corei7;
                s = if (hasFeature(features, .avx512bf16))
                    .intel_corei7_cooperlake
                else if (hasFeature(features, .avx512vnni))
                    .intel_corei7_cascadelake
                else
                    .intel_corei7_skylake_avx512;
            },
            0x66 => {
                t = .intel_corei7;
                s = .intel_corei7_cannonlake;
            },
            0x7d, 0x7e => {
                t = .intel_corei7;
                s = .intel_corei7_icelake_client;
            },
            0x8c, 0x8d => {
                t = .intel_corei7;
                s = .intel_corei7_tigerlake;
            },
            0x97, 0x9a => {
                t = .intel_corei7;
                s = .intel_corei7_alderlake;
            },
            // Raptorlake
            0xb7, 0xba, 0xbf => {
                t = .intel_corei7;
                s = .intel_corei7_alderlake;
            },
            // Meteorlake
            0xaa, 0xac => {
                t = .intel_corei7;
                s = .intel_corei7_alderlake;
            },
            // Gracemont
            0xbe => {
                t = .intel_corei7;
                s = .intel_corei7_alderlake;
            },
            // Arrowlake and Arrowlake U
            0xc5, 0xb5 => {
                t = .intel_corei7;
                s = .intel_corei7_arrowlake;
            },
            // Arrowlake S
            0xc6 => {
                t = .intel_corei7;
                s = .intel_corei7_arrowlake_s;
            },
            // Lunarlake
            0xbd => {
                t = .intel_corei7;
                s = .intel_corei7_arrowlake_s;
            },
            0xcc => {
                t = .intel_corei7;
                s = .intel_corei7_pantherlake;
            },
            // Icelake Xeon
            0x6a, 0x6c => {
                t = .intel_corei7;
                s = .intel_corei7_icelake_server;
            },
            // Emerald Rapids
            0xcf => {
                t = .intel_corei7;
                s = .intel_corei7_sapphirerapids;
            },
            // Sapphire Rapids
            0x8f => {
                t = .intel_corei7;
                s = .intel_corei7_sapphirerapids;
            },
            0xad => {
                t = .intel_corei7;
                s = .intel_corei7_graniterapids;
            },
            0xae => {
                t = .intel_corei7;
                s = .intel_corei7_graniterapids_d;
            },

            0x1c, 0x26, 0x27, 0x35, 0x36 => t = .intel_bonnell,
            0x37, 0x4a, 0x4d, 0x5a, 0x5d, 0x4c => t = .intel_silvermont,
            0x5c, 0x5f => t = .intel_goldmont,
            0x7a => t = .intel_goldmont_plus,
            0x86, 0x8a, 0x96, 0x9c => t = .intel_tremont,
            0xaf => t = .intel_sierraforest,
            0xb6 => t = .intel_grandridge,
            0xdd => t = .intel_clearwaterforest,
            0x57 => t = .intel_knl,
            0x85 => t = .intel_knm,
            else => {},
        },
        else => {},
    }

    return .{ t, s };
}
